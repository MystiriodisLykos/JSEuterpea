// Generated by CoffeeScript 1.12.4

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    * File: PrattParser.coffee
    * -----------------
    * File containing the functions to parse a token string into ASTs
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

(function() {
  var PrattParser, findNonWhite, isOperand, nonWhiteSpace, preParse,
    slice = [].slice;

  isOperand = function(token) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * isOperand(Token token)
        * ----------------
        * Takes a token and decided if its an Operand(true) or an Operator(false)
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var ref;
    if ((ref = token.type) === 'Name' || ref === 'Integer') {
      return true;
    } else {
      return false;
    }
  };

  nonWhiteSpace = function(tokenStream) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * nonWhiteSpace([Token] tokenStream)
        * ----------------
        * Returns the number of non white space tokens in tokenStream
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var curToken, k, len, nonWS, ref;
    nonWS = 0;
    for (k = 0, len = tokenStream.length; k < len; k++) {
      curToken = tokenStream[k];
      if ((ref = curToken.type) !== 'White Space' && ref !== 'Newline') {
        nonWS++;
      }
    }
    return nonWS;
  };

  findNonWhite = function(tokenStream) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * findNonWhite([Token] tokenStream)
        * ----------------
        * Returns the first non white space token in tokenStream
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var curToken, k, len, ref;
    for (k = 0, len = tokenStream.length; k < len; k++) {
      curToken = tokenStream[k];
      if ((ref = curToken.type) !== 'White Space' && ref !== 'Newline') {
        return curToken;
      }
    }
  };

  PrattParser = function(tokenStream) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * PrattParser([Token] tokenStream)
        * ----------------
        * Turns the tokenStream into one large AST recursively
        * The tokenStream may contain predefined ASTs
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var astL, astR, curToken, i, k, len, minPres, minPresIdx, operator, ref, tokenStreamL, tokenStreamR;
    if ((nonWhiteSpace(tokenStream)) === 1) {
      curToken = findNonWhite(tokenStream);
      if (!(curToken instanceof Token)) {
        return curToken;
      }
      switch (curToken.type) {
        case 'Integer':
          return new createAstConst(curToken);
        case 'Name' || 'Symbol':
          return new createAstVar(curToken);
      }
    }
    minPres = 9;
    minPresIdx = 0;
    for (i = k = 0, len = tokenStream.length; k < len; i = ++k) {
      curToken = tokenStream[i];
      if ((ref = curToken.type) !== 'White Space' && ref !== 'Newline') {
        if (curToken.pres <= minPres) {
          minPres = curToken.pres;
          minPresIdx = i;
        }
      }
    }
    tokenStreamL = tokenStream.slice(0, minPresIdx);
    tokenStreamR = tokenStream.slice(minPresIdx + 1);
    astL = PrattParser(tokenStreamL);
    astR = PrattParser(tokenStreamR);
    operator = new createAstVar(tokenStream[minPresIdx]);
    return new createAstApp(operator, astL, astR);
  };

  preParse = function(tokenStream) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * preParser([Token] tokenStream)
        * ----------------
        * This part of the parser creates ASTs out of function calls (ex. f x where f is the function x is the arg)
        * and creates ASTs out of things grouped into parentheses.
        * The return value is the tokenStream with these ASTs inserted
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var arg, column, curToken, endP, endToken, fn, i, j, k, l, len, len1, operator, parNum, parens, ref, res, row;
    res = [];
    operator = false;
    parens = false;
    for (i = k = 0, len = tokenStream.length; k < len; i = ++k) {
      curToken = tokenStream[i];
      if (curToken.type !== 'White Space' && curToken.type !== 'Newline') {
        if (parens) {
          if (curToken.body === ')' && i === endP) {
            parens = false;
            operator = true;
          }
        } else if (curToken.body === '(') {
          endP = -1;
          parNum = 1;
          ref = tokenStream.slice(i + 1);
          for (j = l = 0, len1 = ref.length; l < len1; j = ++l) {
            endToken = ref[j];
            if (endToken.body === '(') {
              parNum++;
            } else if (endToken.body === ')') {
              parNum--;
            }
            if (parNum === 0) {
              endP = j + i + 1;
              break;
            }
          }
          if (endP === -1) {
            console.log('Error Missing closing ")"');
          } else {
            res.push(PrattParser(preParse(tokenStream.slice(i + 1, endP))));
          }
          parens = true;
        } else if (!operator) {
          operator = true;
          if (curToken.body === '-' && (!tokenStream[i - 1] || !isOperand(tokenStream[i - 1]))) {
            column = curToken.column, row = curToken.row;
            res.push(new Token(0, column - 1, row, 'Integer'));
            res.push(curToken);
            operator = false;
          } else if (!isOperand(curToken)) {
            console.log("Error");
            console.log(curToken);
          } else {
            res.push(curToken);
          }
        } else if (operator) {
          operator = false;
          if (isOperand(curToken)) {
            fn = PrattParser([res.pop()]);
            arg = PrattParser([curToken]);
            res.push(new createAstApp(fn, arg));
            operator = true;
          } else {
            res.push(curToken);
          }
        }
      }
    }
    return res;
  };

  this.parser = function(tokenStream) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * parser([Token] tokenStream) Global
        * ----------------
        * Global function that takes tokenStream and turns it into an array of
        * ASTDefinitions that get added to the enviornmnet
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var args, backwards, body, curToken, defArr, e, endToken, i, idx, j, k, l, len, len1, len2, m, name, ref, retAst;
    name = '';
    body = '';
    defArr = [];
    for (i = k = 0, len = tokenStream.length; k < len; i = ++k) {
      curToken = tokenStream[i];
      if (curToken.body === '=') {
        args = [];
        name = '';
        backwards = tokenStream.slice(0, i).reverse();
        for (j = l = 0, len1 = backwards.length; l < len1; j = ++l) {
          e = backwards[j];
          if (e.type !== 'White Space' && e.body !== ':') {
            if (!backwards[j + 1] || !backwards[j + 2] || backwards[j + 1].type === 'Newline' || backwards[j + 2].type === 'Newline') {
              name = e;
              break;
            }
            if (backwards[j + 1].body === ':' || backwards[j + 2].body === ':') {
              args.unshift(e);
            } else {
              args.unshift(e);
              if (backwards[j + 1].type === 'White Space') {
                name = backwards[j + 2];
              } else {
                name = backwards[j + 1];
              }
              break;
            }
          }
        }
        idx = -1;
        ref = tokenStream.slice(i + 1);
        for (j = m = 0, len2 = ref.length; m < len2; j = ++m) {
          endToken = ref[j];
          if (endToken.type === 'Newline') {
            if (tokenStream[j + i + 2]) {
              if (tokenStream[j + i + 2].type !== 'White Space') {
                idx = j + i + 1;
                break;
              }
            } else {
              idx = j + i + 1;
              break;
            }
          }
        }
        body = tokenStream.slice(i + 1, idx);
        retAst = PrattParser(preParse(body));
        if (args.length > 0) {
          retAst = (function(func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
          })(ASTLambda, [retAst].concat(slice.call(args)), function(){});
        }
        defArr.push(new createAstDef(name, retAst));
      }
    }
    return createDefs(defArr);
  };

}).call(this);

//# sourceMappingURL=PrattParser_N.js.map
