// Generated by CoffeeScript 1.12.4

/* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    * File: Token.coffee
    * -----------------
    * Contains code to create Tokens and to tokenize a string array
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

(function() {
  var tokenTypes;

  tokenTypes = {
    '^\\s+': 'White Space',
    '^\\d+\\.?\\d*': 'Number',
    '^[()\\[\\]{},;`]': 'Special'
  };

  this.Token = (function() {
    function Token(body1, column, row1, type1, pres1, assoc1) {
      this.body = body1;
      this.column = column;
      this.row = row1;
      this.type = type1;
      this.pres = pres1;
      this.assoc = assoc1;

      /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          * constructor (body, Int column, Int row, String type, Int pres, Int assoc)
          * ----------------
          * Constructor for a Token.
          * type :: [Integer, Special, White Space, Symbol, Name]
          ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       */
    }

    return Token;

  })();

  this.tokenize = function(lineArr) {

    /* ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        * tokenize ([String] lineArr)
        * ----------------
        * Takes a token and decided if its an Operand(true) or an Operator(false)
        ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     */
    var assoc, body, col, i, len, match, pres, re, ref, res, row, s, type;
    res = [];
    for (i = 0, len = lineArr.length; i < len; i++) {
      ref = lineArr[i], row = ref[0], s = ref[1];
      col = 0;
      while (s !== '') {
        match = false;
        for (re in tokenTypes) {
          type = tokenTypes[re];
          re = new RegExp(re);
          if (re.test(s)) {
            body = (re.exec(s))[0];
            match = true;
            pres = getPres(body);
            assoc = getAssoc(body);
            res.push(new Token(body, col, row, type, pres, assoc));
            col += body.length;
            s = s.replace(re, '');
            break;
          }
        }
        if (!match) {
          throw 'Unknown character';
        }
      }
    }
    return res;
  };

}).call(this);

//# sourceMappingURL=Token_N.js.map
